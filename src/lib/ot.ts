import { query } from '@/lib/db'
export type OtRule={ daily_threshold_minutes:number; weekend_multiplier:number; holiday_multiplier:number; night_window?:{from:string;to:string;multiplier:number}; rounding?:{step:number;mode:'ceil'|'floor'|'round'} }
function parseHHMM(t:string){ const [h,m]=t.split(':').map(Number); return h*60+m }
function inNight(m:number, from:number,to:number){ return from<=to? (m>=from && m<to) : (m>=from || m<to) }
function applyRounding(mins:number, step=15, mode:'ceil'|'floor'|'round'='ceil'){ const f=mins/step; if(mode==='ceil') return Math.ceil(f)*step; if(mode==='floor') return Math.floor(f)*step; return Math.round(f)*step }
export async function getActiveOtRule(onDate:Date){ const {rows}=await query<any>(`SELECT cfg FROM overtime_rules WHERE effective_from <= $1 ORDER BY effective_from DESC LIMIT 1`,[onDate.toISOString().slice(0,10)]); return rows[0]?.cfg||{daily_threshold_minutes:480,weekend_multiplier:1.5,holiday_multiplier:2.0} }
export async function isHoliday(d:Date){ const {rows}=await query<any>(`SELECT 1 FROM holidays WHERE date=$1`,[d.toISOString().slice(0,10)]); return !!rows[0] }
export async function getShift(employee_id:number, d:Date){ const {rows}=await query<any>(`SELECT s.* FROM shift_assignments sa JOIN shifts s ON s.id=sa.shift_id WHERE sa.employee_id=$1 AND sa.effective_from <= $2 AND (sa.effective_to IS NULL OR sa.effective_to >= $2) ORDER BY sa.effective_from DESC LIMIT 1`,[employee_id,d.toISOString().slice(0,10)]); return rows[0]||null }
export function computeDay(d:Date, shift:any, punches:{ts:string,action:'check_in'|'check_out'}[], rule:OtRule, holiday:boolean){ punches.sort((a,b)=>new Date(a.ts).getTime()-new Date(b.ts).getTime()); const pairs: Array<{in:number,out:number}> = []; let lastIn:number|undefined; for(const p of punches){ const dt=new Date(p.ts); const m=dt.getUTCHours()*60+dt.getUTCMinutes(); if(p.action==='check_in') lastIn=m; else if(p.action==='check_out' && lastIn!=null){ pairs.push({in:lastIn,out:m}); lastIn=undefined } } let worked=0, night=0; const nf=rule.night_window?parseHHMM(rule.night_window.from):null; const nt=rule.night_window?parseHHMM(rule.night_window.to):null; for(const itv of pairs){ const dur=Math.max(0,itv.out-itv.in); worked+=dur; if(nf!=null && nt!=null){ for(let m=itv.in;m<itv.out;m++) if(inNight(m,nf,nt)) night++ } } let scheduled=0; if(shift){ const st=parseHHMM(shift.start_time); const et=parseHHMM(shift.end_time); const base=shift.overnight? (24*60-st+et):(et-st); scheduled=Math.max(0, base-(shift.break_minutes||0)) } let late=0, early=0; if(shift&&pairs[0]){ const st=parseHHMM(shift.start_time); const firstIn=pairs[0].in; if(firstIn>st) late=firstIn-st } if(shift&&pairs[pairs.length-1]){ const et=parseHHMM(shift.end_time); const lastOut=pairs[pairs.length-1].out; if(!shift.overnight && lastOut<et) early=et-lastOut } const threshold=rule.daily_threshold_minutes??scheduled; let ot=Math.max(0, worked-threshold); if(rule.rounding) ot=applyRounding(ot, rule.rounding.step, rule.rounding.mode); let ot_regular=0, ot_weekend=0, ot_holiday=0; const dow=d.getUTCDay(); const weekend=Array.isArray(shift?.weekly_off)?(shift.weekly_off as number[]).includes(dow):false; if(holiday){ ot_holiday=ot } else if(weekend){ ot_weekend=ot } else { ot_regular=ot } return { scheduled, worked, night, late, early, ot_regular, ot_weekend, ot_holiday } }
export function weekWindow(dateISO:string, start:'fri'|'sat'|'sun'='sun'){ const d=new Date(dateISO+'T00:00:00Z'); const dow=d.getUTCDay(); const offset=start==='sun'?dow: start==='sat'?(dow==6?0:(dow+1)):((dow+2)%7); const s=new Date(d); s.setUTCDate(d.getUTCDate()-offset); const e=new Date(s); e.setUTCDate(s.getUTCDate()+6); return { start: s.toISOString().slice(0,10), end: e.toISOString().slice(0,10) } }
export function capOtMinutes(m:{regular:number;weekend:number;holiday:number}, dayCap?:number, weekUsed?:number, weekCap?:number){ const total=m.regular+m.weekend+m.holiday; let allowed=total; if(dayCap!=null) allowed=Math.min(allowed,dayCap); if(weekCap!=null && weekUsed!=null) allowed=Math.min(allowed, Math.max(0, weekCap-weekUsed)); if(allowed>=total) return m; let r=m.regular,w=m.weekend,h=m.holiday; let over=total-allowed; const take=(x:number)=>{ const d=Math.min(x,over); over-=d; return x-d }; r=take(r); if(over>0) w=take(w); if(over>0) h=take(h); return { regular:Math.max(0,r), weekend:Math.max(0,w), holiday:Math.max(0,h) } }
